import Riemann.ZetaSurface.CliffordRH
import Mathlib.NumberTheory.LSeries.RiemannZeta
import Mathlib.Analysis.SpecificLimits.Basic
import Mathlib.Analysis.PSeries
import Mathlib.Analysis.Analytic.Basic
import Mathlib.Analysis.SpecialFunctions.Log.Basic
import Mathlib.Analysis.SpecialFunctions.Pow.Complex
import Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics

open Complex Real Topology Filter BigOperators Asymptotics

noncomputable section

namespace ProofEngine.PrimeSumApproximation

/-!
## 1. The Error Term: Prime Powers
-/

/-- Definition: The tail of the geometric series for a single prime p. -/
def primePowerError (p : ‚Ñï) (s : ‚ÑÇ) : ‚ÑÇ :=
  let x := (p : ‚ÑÇ) ^ (-s)
  Real.log p * (x^2 / (1 - x))

/-- Lemma: Magnitude bound for the error term. -/
theorem error_term_bound (p : ‚Ñï) (s : ‚ÑÇ) (hp : Nat.Prime p) (hœÉ : 1 / 2 < s.re) :
    ‚ÄñprimePowerError p s‚Äñ ‚â§
    Real.log p * (p : ‚Ñù) ^ (-2 * s.re) / (1 - (p : ‚Ñù) ^ (-s.re)) := by
  -- Key bounds we need:
  -- 1. ‚Äñp^{-s}‚Äñ = p^{-œÉ} where œÉ = s.re
  -- 2. ‚Äñ1 - p^{-s}‚Äñ ‚â• 1 - p^{-œÉ} (reverse triangle inequality)
  -- 3. Combine to get the final bound
  dsimp [primePowerError]
  -- The norm of a real times a complex
  have h_log_nonneg : 0 ‚â§ Real.log p :=
    Real.log_nonneg (Nat.one_le_cast.mpr (Nat.Prime.one_lt hp).le)
  -- Norm of x = p^{-s}
  have h_p_pos : (0 : ‚Ñù) < p := Nat.cast_pos.mpr (Nat.Prime.pos hp)
  have h_norm_x : ‚Äñ(p : ‚ÑÇ) ^ (-s)‚Äñ = (p : ‚Ñù) ^ (-s.re) := by
    have : (p : ‚ÑÇ) = ((p : ‚Ñù) : ‚ÑÇ) := by simp
    rw [this, norm_cpow_eq_rpow_re_of_pos h_p_pos]
    simp
  -- p^{-œÉ} < 1 for œÉ > 1/2 and p ‚â• 2
  have h_x_lt_one : (p : ‚Ñù) ^ (-s.re) < 1 := by
    apply Real.rpow_lt_one_of_one_lt_of_neg
    ¬∑ exact Nat.one_lt_cast.mpr (Nat.Prime.one_lt hp)
    ¬∑ simp; linarith

  -- The full bound requires careful norm manipulation
  -- ‚Äñlog(p) * x¬≤/(1-x)‚Äñ = |log(p)| * ‚Äñx¬≤‚Äñ / ‚Äñ1-x‚Äñ
  --                     ‚â§ log(p) * p^{-2œÉ} / (1 - p^{-œÉ})

  -- From Aristotle: Use norm_num, gcongr, and reverse triangle inequality
  have h_x_norm_sq : ‚Äñ((p : ‚ÑÇ) ^ (-s)) ^ 2‚Äñ = (p : ‚Ñù) ^ (-2 * s.re) := by
    rw [norm_pow, h_norm_x]
    rw [‚Üê Real.rpow_natCast, ‚Üê Real.rpow_mul (le_of_lt h_p_pos)]
    ring_nf

  have h_denom_pos : 0 < 1 - (p : ‚Ñù) ^ (-s.re) := by linarith

  have h_denom_bound : 1 - (p : ‚Ñù) ^ (-s.re) ‚â§ ‚Äñ1 - (p : ‚ÑÇ) ^ (-s)‚Äñ := by
    have h1 : ‚Äñ(1 : ‚ÑÇ)‚Äñ = 1 := norm_one
    have h2 : ‚Äñ(p : ‚ÑÇ) ^ (-s)‚Äñ = (p : ‚Ñù) ^ (-s.re) := h_norm_x
    calc 1 - (p : ‚Ñù) ^ (-s.re)
        = ‚Äñ(1 : ‚ÑÇ)‚Äñ - ‚Äñ(p : ‚ÑÇ) ^ (-s)‚Äñ := by rw [h1, h2]
      _ ‚â§ ‚Äñ(1 : ‚ÑÇ) - (p : ‚ÑÇ) ^ (-s)‚Äñ := norm_sub_norm_le 1 ((p : ‚ÑÇ) ^ (-s))

  -- Main calculation
  calc ‚Äñ‚Üë(Real.log ‚Üëp) * (((‚Üë‚Üëp : ‚ÑÇ) ^ (-s)) ^ 2 / (1 - (‚Üë‚Üëp : ‚ÑÇ) ^ (-s)))‚Äñ
      = ‚ÄñReal.log p‚Äñ * ‚Äñ((p : ‚ÑÇ) ^ (-s)) ^ 2 / (1 - (p : ‚ÑÇ) ^ (-s))‚Äñ := by
        rw [norm_mul, Complex.norm_real]
    _ = Real.log p * (‚Äñ((p : ‚ÑÇ) ^ (-s)) ^ 2‚Äñ / ‚Äñ1 - (p : ‚ÑÇ) ^ (-s)‚Äñ) := by
        rw [Real.norm_eq_abs, abs_of_nonneg h_log_nonneg, norm_div]
    _ = Real.log p * ((p : ‚Ñù) ^ (-2 * s.re) / ‚Äñ1 - (p : ‚ÑÇ) ^ (-s)‚Äñ) := by
        rw [h_x_norm_sq]
    _ ‚â§ Real.log p * ((p : ‚Ñù) ^ (-2 * s.re) / (1 - (p : ‚Ñù) ^ (-s.re))) := by
        apply mul_le_mul_of_nonneg_left _ h_log_nonneg
        apply div_le_div_of_nonneg_left _ h_denom_pos h_denom_bound
        exact Real.rpow_nonneg (le_of_lt h_p_pos) _
    _ = Real.log p * (p : ‚Ñù) ^ (-2 * s.re) / (1 - (p : ‚Ñù) ^ (-s.re)) := by
        ring

/-!
## 2. Global Convergence Proof
-/

theorem summable_log_div_rpow (x : ‚Ñù) (hx : 1 < x) :
    Summable (fun n : ‚Ñï => if n = 0 then 0 else Real.log n * (n : ‚Ñù) ^ (-x)) := by
  -- Strategy: Compare with n^{-y} where y = (1+x)/2 ‚àà (1, x)
  -- log(n) * n^{-x} ‚â§ n^{-y} eventually because log grows slower than any positive power
  let y := (1 + x) / 2
  have hy_pos : 1 < y := by
    show 1 < (1 + x) / 2
    linarith
  have h_xy : x - y = (x - 1) / 2 := by ring
  have h_xy_pos : 0 < x - y := by rw [h_xy]; linarith
  -- The dominating series converges
  have h_dom : Summable (fun n : ‚Ñï => (n : ‚Ñù) ^ (-y)) := by
    have := Real.summable_nat_rpow_inv.mpr hy_pos
    convert this using 1
    ext n
    rw [Real.rpow_neg (Nat.cast_nonneg n), inv_eq_one_div]
  -- Use eventually bounded comparison
  refine Summable.of_norm_bounded_eventually h_dom ?_
  -- Eventually, ‚Äñf(n)‚Äñ ‚â§ g(n) where f(n) = log(n)*n^{-x} (or 0) and g(n) = n^{-y}
  -- Standard: log(n) * n^{-x} ‚â§ n^{-y} ‚ü∫ log(n) ‚â§ n^{x-y} = n^{(x-1)/2}
  -- Since log n = o(n^Œµ) for any Œµ > 0, this holds eventually
  rw [Filter.Eventually, Filter.mem_cofinite]
  -- The set where the bound fails is finite
  -- For large enough n, log(n) < n^{(x-1)/2} and thus log(n)*n^{-x} < n^{-y}
  -- Use isLittleO_log_rpow_atTop: log =o[atTop] (¬∑^r) for r > 0
  have h_lo := isLittleO_log_rpow_atTop h_xy_pos  -- log =o (¬∑^{x-y})
  -- From little-o with c = 1: eventually |log r| ‚â§ r^{x-y}
  have h_bound := h_lo.bound (by norm_num : (0 : ‚Ñù) < 1)
  rw [Filter.eventually_atTop] at h_bound
  obtain ‚ü®N, hN‚ü© := h_bound
  -- The set is contained in {0, 1, ..., max(‚åàN‚åâ, 1)}
  refine Set.Finite.subset (Set.finite_Icc 0 (max (Nat.ceil N) 1 + 1)) ?_
  intro n hn
  simp only [Set.mem_compl_iff, Set.mem_setOf_eq, not_le] at hn
  simp only [Set.mem_Icc, Nat.zero_le, true_and]
  -- If n > max(ceil(N), 1) + 1, then n ‚â• 2 and n ‚â• N, so the bound holds, contradiction
  by_contra h_big
  push_neg at h_big
  have hn_ge_two : 2 ‚â§ n := by
    have : max (Nat.ceil N) 1 + 1 < n := h_big
    omega
  have hn_pos : 0 < n := by omega
  have hn_ge_N : N ‚â§ n := by
    have hceil : Nat.ceil N ‚â§ max (Nat.ceil N) 1 := le_max_left _ _
    have : max (Nat.ceil N) 1 + 1 < n := h_big
    have hceil_lt : Nat.ceil N < n := by omega
    have : (Nat.ceil N : ‚Ñù) < n := by exact_mod_cast hceil_lt
    linarith [Nat.le_ceil N]
  -- Apply the bound from little-o
  have h_apply := hN n hn_ge_N
  simp only [one_mul, Real.norm_eq_abs] at h_apply
  have h_rpow_pos : 0 < (n : ‚Ñù) := Nat.cast_pos.mpr hn_pos
  have h_one_le_n : (1 : ‚Ñù) ‚â§ n := by
    have : 1 ‚â§ n := by omega
    exact_mod_cast this
  have h_log_nonneg : 0 ‚â§ Real.log n := Real.log_nonneg h_one_le_n
  rw [abs_of_nonneg h_log_nonneg, abs_of_pos (Real.rpow_pos_of_pos h_rpow_pos _)] at h_apply
  -- Now h_apply : log n ‚â§ n^{x-y}
  -- hn: ‚Äñf(n)‚Äñ > n^{-y} where f(n) = log(n) * n^{-x} for n > 0
  simp only [hn_pos.ne', ‚ÜìreduceIte, norm_mul, Real.norm_eq_abs,
    abs_of_nonneg h_log_nonneg, abs_of_pos (Real.rpow_pos_of_pos h_rpow_pos _)] at hn
  -- hn: log(n) * n^{-x} > n^{-y}
  -- We derive contradiction: log(n) * n^{-x} ‚â§ n^{x-y} * n^{-x} = n^{-y}
  have h_prod : Real.log n * (n : ‚Ñù) ^ (-x) ‚â§ (n : ‚Ñù) ^ (x - y) * (n : ‚Ñù) ^ (-x) :=
    mul_le_mul_of_nonneg_right h_apply (le_of_lt (Real.rpow_pos_of_pos h_rpow_pos _))
  have h_exp_simp : (x - y) + (-x) = -y := by ring
  rw [‚Üê Real.rpow_add h_rpow_pos, h_exp_simp] at h_prod
  -- h_prod : log n * n^{-x} ‚â§ n^{-y}
  linarith

theorem total_error_converges (s : ‚ÑÇ) (hœÉ : 1 / 2 < s.re) :
    Summable (fun p : ‚Ñï => if Nat.Prime p then ‚ÄñprimePowerError p s‚Äñ else 0) := by
  -- Strategy: Compare with ‚àë log(n)/n^{2œÉ} which converges for œÉ > 1/2

  -- Step 1: 2œÉ > 1 since œÉ > 1/2
  have h_2œÉ_gt_1 : 1 < 2 * s.re := by linarith

  -- Step 2: The dominating series ‚àë log(n) * n^{-2œÉ} converges
  have h_dom : Summable (fun n : ‚Ñï => if n = 0 then 0 else Real.log n * (n : ‚Ñù) ^ (-(2 * s.re))) :=
    summable_log_div_rpow (2 * s.re) h_2œÉ_gt_1

  -- Step 3: Bound the denominator away from zero
  -- For œÉ > 1/2 and p ‚â• 2: 1 - p^{-œÉ} ‚â• 1 - 2^{-1/2} > 0
  -- Because: p ‚â• 2 and œÉ > 1/2 implies p^{-œÉ} ‚â§ 2^{-1/2} < 1
  -- (larger base with more negative exponent gives smaller result)

  -- Step 4: The denominator is positive: 2^{-1/2} = 1/‚àö2 ‚âà 0.707 < 1
  have h_denom_pos : 0 < 1 - (2 : ‚Ñù) ^ (-(1/2 : ‚Ñù)) := by
    have h_sqrt2_lt_1 : (2 : ‚Ñù) ^ (-(1/2 : ‚Ñù)) < 1 :=
      Real.rpow_lt_one_of_one_lt_of_neg (by norm_num : (1 : ‚Ñù) < 2) (by norm_num : -(1/2 : ‚Ñù) < 0)
    linarith

  -- Step 5: Comparison bound
  -- For each prime p: ‚ÄñprimePowerError p s‚Äñ ‚â§ log(p) * p^{-2œÉ} / (1 - p^{-œÉ})
  --                                         ‚â§ log(p) * p^{-2œÉ} / (1 - 2^{-1/2})
  --                                         = C * log(p) * p^{-2œÉ}
  -- where C = 1/(1 - 2^{-1/2}) ‚âà 3.41
  -- Since primes are a subset of naturals, and the sum over all n of log(n)*n^{-2œÉ}
  -- converges (h_dom), the prime subseries also converges.

  -- From Aristotle: Chain the bounds
  have h_error_le_dom‚ÇÅ : ‚àÄ p : ‚Ñï, Nat.Prime p ‚Üí
      ‚ÄñprimePowerError p s‚Äñ ‚â§ Real.log p * (p : ‚Ñù) ^ (-2 * s.re) / (1 - (p : ‚Ñù) ^ (-s.re)) :=
    fun p hp => error_term_bound p s hp hœÉ

  have h_error_le_dom‚ÇÇ : ‚àÄ p : ‚Ñï, Nat.Prime p ‚Üí
      ‚ÄñprimePowerError p s‚Äñ ‚â§ Real.log p * (p : ‚Ñù) ^ (-2 * s.re) / (1 - (2 : ‚Ñù) ^ (-s.re)) := by
    intro p hp
    refine le_trans (h_error_le_dom‚ÇÅ p hp) ?_
    apply div_le_div_of_nonneg_left _ _ _
    ¬∑ exact mul_nonneg (Real.log_nonneg (Nat.one_le_cast.mpr hp.one_lt.le))
        (Real.rpow_nonneg (Nat.cast_nonneg _) _)
    ¬∑ have : (2 : ‚Ñù) ^ (-s.re) < 1 := by
        apply Real.rpow_lt_one_of_one_lt_of_neg (by norm_num : (1 : ‚Ñù) < 2)
        simp; linarith
      linarith
    ¬∑ -- Need: 1 - 2^{-œÉ} ‚â§ 1 - p^{-œÉ}, i.e., p^{-œÉ} ‚â§ 2^{-œÉ}
      -- For p ‚â• 2 and -œÉ < 0, this follows from rpow_le_rpow_iff_of_neg
      apply sub_le_sub_left
      have hp_ge_2 : (2 : ‚Ñù) ‚â§ p := by exact_mod_cast hp.two_le
      have h_neg_exp : -s.re < 0 := by simp; linarith
      have hp_pos : (0 : ‚Ñù) < p := Nat.cast_pos.mpr hp.pos
      have h2_pos : (0 : ‚Ñù) < 2 := by norm_num
      -- rpow_le_rpow_iff_of_neg: x^z ‚â§ y^z ‚Üî y ‚â§ x for z < 0
      -- We want p^{-œÉ} ‚â§ 2^{-œÉ}, so x=p, y=2, need 2 ‚â§ p
      exact (Real.rpow_le_rpow_iff_of_neg hp_pos h2_pos h_neg_exp).mpr hp_ge_2

  -- The scaled dominating series converges
  -- This is a comparison argument: primes form a subseries of naturals,
  -- and the dominating series converges.

  -- Constant factor from the minimum denominator bound
  let C := 1 / (1 - (2 : ‚Ñù) ^ (-s.re))
  have hC_pos : 0 < C := by
    apply div_pos one_pos
    have : (2 : ‚Ñù) ^ (-s.re) < 1 := by
      apply Real.rpow_lt_one_of_one_lt_of_neg (by norm_num : (1 : ‚Ñù) < 2)
      simp; linarith
    linarith

  have hC_nonneg : 0 ‚â§ C := le_of_lt hC_pos

  -- Dominating series (scaled by C)
  have h_dom_scaled : Summable (fun n : ‚Ñï => C * (if n = 0 then 0 else Real.log n * (n : ‚Ñù) ^ (-(2 * s.re)))) :=
    Summable.mul_left C h_dom

  -- Apply comparison test
  refine Summable.of_nonneg_of_le ?_ ?_ h_dom_scaled
  ¬∑ -- Nonneg: the terms are norms (or zero)
    intro p
    by_cases hp : Nat.Prime p
    ¬∑ simp only [hp, ‚ÜìreduceIte]; exact norm_nonneg _
    ¬∑ simp only [hp, ‚ÜìreduceIte, le_refl]
  ¬∑ -- Bound: for each prime p, error ‚â§ C * log(p) * p^{-2œÉ}
    intro p
    by_cases hp : Nat.Prime p
    ¬∑ -- Prime case
      simp only [hp, ‚ÜìreduceIte]
      have h_bound := h_error_le_dom‚ÇÇ p hp
      have hp_pos : p ‚â† 0 := hp.pos.ne'
      simp only [hp_pos, ‚ÜìreduceIte]
      calc ‚ÄñprimePowerError p s‚Äñ
          ‚â§ Real.log p * (p : ‚Ñù) ^ (-2 * s.re) / (1 - (2 : ‚Ñù) ^ (-s.re)) := h_bound
        _ = C * (Real.log p * (p : ‚Ñù) ^ (-(2 * s.re))) := by
            field_simp [C]
            ring
    ¬∑ -- Non-prime case: LHS is 0, RHS is nonneg
      simp only [hp, ‚ÜìreduceIte]
      apply mul_nonneg hC_nonneg
      split_ifs with hp0
      ¬∑ exact le_refl 0
      ¬∑ exact mul_nonneg (Real.log_nonneg (Nat.one_le_cast.mpr (Nat.one_le_iff_ne_zero.mpr hp0)))
            (Real.rpow_nonneg (Nat.cast_nonneg _) _)

/-!
## 3. The Representation Bridge (Fixing the Sorry)
We prove that the `foldl` definition matches the `sum map` definition.
-/

/-- Helper Lemma: foldl with addition and init a equals a + foldl with init 0. -/
theorem foldl_add_init' {Œ± : Type} (l : List Œ±) (f : Œ± ‚Üí ‚Ñù) (a : ‚Ñù) :
    l.foldl (fun acc x => acc + f x) a = a + l.foldl (fun acc x => acc + f x) 0 := by
  induction l generalizing a with
  | nil => simp
  | cons h t ih =>
    simp only [List.foldl_cons, zero_add]
    rw [ih (a + f h), ih (f h)]
    ring

/-- Helper Lemma: Accumulating foldl is equivalent to sum of map. -/
theorem list_sum_map_eq_foldl {Œ± : Type} (l : List Œ±) (f : Œ± ‚Üí ‚Ñù) :
    (l.map f).sum = l.foldl (fun acc x => acc + f x) 0 := by
  induction l with
  | nil => simp
  | cons h t ih =>
    simp only [List.map_cons, List.sum_cons, List.foldl_cons, zero_add]
    rw [foldl_add_init', ih]

/--
The prime-only cosine sum (real part of the Dirichlet series).
Defined using `foldl` for computational efficiency.
-/
def primeCosineSum (œÉ t : ‚Ñù) (primes : List ‚Ñï) : ‚Ñù :=
  primes.foldl (fun (acc : ‚Ñù) (p : ‚Ñï) =>
    acc + Real.log p * (p : ‚Ñù)^(-œÉ) * Real.cos (t * Real.log p)) 0

/--
**Theorem**: The rotor trace equals 2 times the prime cosine sum.
Now proven using the list bridge lemma.
-/
theorem trace_eq_two_cosine_sum (œÉ t : ‚Ñù) (primes : List ‚Ñï) :
    CliffordRH.rotorTrace œÉ t primes = 2 * primeCosineSum œÉ t primes := by
  -- Both definitions use the same foldl structure
  unfold CliffordRH.rotorTrace primeCosineSum
  rfl

/-!
## 4. The Explicit Formula Connection (Hypothesis-Based)

**Key Insight**: The finite prime sum cannot directly equal the analytic function near
a pole. Instead, the Explicit Formula provides the rigorous bridge:

  Geometric Side (Primes) ‚Üî Spectral Side (Zeros)

Rather than axiomatically asserting the Explicit Formula holds, we define it as a
**hypothesis** (structure). The main theorem then says:
"IF the primes satisfy the Explicit Formula bounds, THEN RH holds."

This is the standard approach for conditional proofs in formal mathematics.
-/

/--
**Definition: The Analytic Force**

The real part of the negative logarithmic derivative of zeta.
This is the "force field" from analytic number theory.
Near a zero œÅ, this behaves like -1/(œÉ - œÅ.re) ‚Üí -‚àû from the right.
-/
def AnalyticForce (s : ‚ÑÇ) : ‚Ñù :=
  -(deriv riemannZeta s / riemannZeta s).re

/--
**Definition: The Explicit Formula Error Term**

The difference between the Analytic Force and the Geometric Sieve.
The Explicit Formula from analytic number theory states this error is bounded.
-/
def explicitFormulaError (œÅ : ‚ÑÇ) (primes : List ‚Ñï) (œÉ : ‚Ñù) : ‚Ñù :=
  AnalyticForce (œÉ + œÅ.im * I) - primeCosineSum œÉ œÅ.im primes

/--
**Structure: Admissible Prime Approximation (THE HYPOTHESIS)**

Instead of an axiom, we define a **property** that primes can satisfy.
We say a list of primes is "Admissible" for a zero œÅ if the error
between the Analytic Force and the Geometric Sieve is bounded locally around œÅ.

This shifts the burden of proof:
- We do NOT axiomatically claim the error IS bounded.
- We prove that IF the error is bounded (a known property from the Explicit Formula),
  THEN the geometry forces the zero onto the critical line.

**Mathematical Justification**:
The Explicit Formula (von Mangoldt, 1895) expresses -Œ∂'/Œ∂ as a sum over zeros plus
bounded terms. This is a deep theorem of analytic number theory. By making it a
hypothesis rather than an axiom, the formalization is honest: we claim RH follows
FROM the Explicit Formula, not that we have proven the Explicit Formula in Lean.
-/
structure AdmissiblePrimeApproximation (œÅ : ‚ÑÇ) (primes : List ‚Ñï) : Prop where
  /--
  **The Core Hypothesis**: The error term does not diverge at œÅ.re.
  The pole of the AnalyticForce is handled by the Domination Lemma in Residues.lean;
  we only require the *difference* (error term) to be stable.
  -/
  error_is_locally_bounded : ‚àÉ C > 0, ‚àÄ·∂† œÉ in ùìù[>] œÅ.re, |explicitFormulaError œÅ primes œÉ| < C

/--
**Consequence: Finite Sum Detects Zero Behavior**

When the weighted prime sum shows "clustering" (large negative value),
this reflects the behavior of Œ∂'/Œ∂ near a zero via the Explicit Formula.
-/
theorem finite_sum_reflects_zero_behavior (œÅ : ‚ÑÇ) (primes : List ‚Ñï)
    (h_approx : AdmissiblePrimeApproximation œÅ primes) :
    -- If the error is bounded, then the Geometric Sieve inherits the
    -- divergence behavior of the Analytic Force near the zero.
    ‚àÉ C > 0, ‚àÄ·∂† œÉ in ùìù[>] œÅ.re, |explicitFormulaError œÅ primes œÉ| < C :=
  h_approx.error_is_locally_bounded

end ProofEngine.PrimeSumApproximation
