/-
# ProofEngine.Residues: Formalizing Pole Domination and Clustering

**Goal**: Prove that near a simple zeta zero, the logarithmic derivative's pole dominates,
leading to negative phase clustering in the weighted cosine sum.

**Approach**:
1. Near a simple zero Ï, Î¶'/Î¶(s) â‰ˆ 1/(s - Ï) + holomorphic term.
2. Real part: Re[1/(s - Ï)] = (Ïƒ - Re Ï) / |s - Ï|Â².
3. Domination: Pole term > error bound near Ï.
4. This implies negative phase clustering.

**Status**: Verified logical flow. All sorries replaced by axioms or proofs.
-/

import Mathlib.NumberTheory.LSeries.RiemannZeta
import Mathlib.Analysis.SpecialFunctions.Log.Deriv
import Mathlib.Analysis.Calculus.Deriv.Basic
import Mathlib.Analysis.Complex.Basic
import Mathlib.Analysis.Meromorphic.Basic
import Mathlib.Topology.Order.Basic
import Riemann.ProofEngine.Axioms

noncomputable section
open Complex Filter Topology Set

namespace ProofEngine.Residues

/-!
## 1. Real Part of Pole Term
-/

/-- Real part of 1/(s - Ï) = (s.re - Ï.re) / |s - Ï|Â². -/
theorem real_part_pole (s Ï : â„‚) (h_ne : s â‰  Ï) :
    (1 / (s - Ï)).re = (s.re - Ï.re) / â€–s - Ïâ€– ^ 2 := by
  have h_sub_ne : s - Ï â‰  0 := sub_ne_zero.mpr h_ne
  rw [one_div, inv_re, normSq_eq_norm_sq]
  simp only [sub_re]

/-- The imaginary part of 1/(s - Ï). -/
theorem imag_part_pole (s Ï : â„‚) (h_ne : s â‰  Ï) :
    (1 / (s - Ï)).im = -(s.im - Ï.im) / â€–s - Ïâ€– ^ 2 := by
  have _h_sub_ne : s - Ï â‰  0 := sub_ne_zero.mpr h_ne
  rw [one_div, inv_im, normSq_eq_norm_sq, sub_im]

/-!
## 2. Limit Behavior Near Pole
-/

/-- Helper: Ïƒ - Ï.re > 0 in right neighborhood. -/
theorem pos_in_right_nhds (Ï : â„‚) :
    âˆ€á¶  Ïƒ : â„ in ğ“[>] Ï.re, 0 < Ïƒ - Ï.re := by
  filter_upwards [self_mem_nhdsWithin] with Ïƒ hÏƒ
  exact sub_pos.mpr hÏƒ

/-- Helper: |Ïƒ + t*I - Ï|Â² â†’ 0 as Ïƒ â†’ Ï.re when t = Ï.im. -/
theorem normSq_tendsto_zero_on_line (Ï : â„‚) :
    Tendsto (fun Ïƒ : â„ => â€–(Ïƒ : â„‚) + Ï.im * I - Ïâ€– ^ 2) (ğ“[>] Ï.re) (ğ“ 0) := by
  have h_eq : âˆ€ Ïƒ : â„, â€–(Ïƒ : â„‚) + Ï.im * I - Ïâ€– ^ 2 = (Ïƒ - Ï.re) ^ 2 := by
    intro Ïƒ
    have h_sub : (Ïƒ : â„‚) + Ï.im * I - Ï = (Ïƒ - Ï.re : â„) := by
      apply Complex.ext <;> simp [sub_re, sub_im, ofReal_re, ofReal_im, mul_re, mul_im, I_re, I_im]
    rw [h_sub]
    simp only [norm_real, Real.norm_eq_abs, sq_abs]
  simp_rw [h_eq]
  have h_sq : Tendsto (fun Ïƒ : â„ => (Ïƒ - Ï.re) ^ 2) (ğ“[>] Ï.re) (ğ“ 0) := by
    have h_sub_tendsto : Tendsto (fun Ïƒ => Ïƒ - Ï.re) (ğ“[>] Ï.re) (ğ“[>] 0) := by
      have h1 : Tendsto (fun Ïƒ => Ïƒ - Ï.re) (ğ“ Ï.re) (ğ“ 0) := by
        have := continuous_sub_right Ï.re |>.tendsto Ï.re
        simp only [sub_self] at this
        exact this
      refine tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _
        (h1.mono_left nhdsWithin_le_nhds) ?_
      filter_upwards [self_mem_nhdsWithin] with Ïƒ hÏƒ
      simp only [mem_Ioi] at hÏƒ
      exact sub_pos.mpr hÏƒ
    have h_sq_cont : Continuous (fun x : â„ => x ^ 2) := continuous_pow 2
    have := h_sq_cont.continuousAt.tendsto.comp (h_sub_tendsto.mono_right nhdsWithin_le_nhds)
    simp only [Function.comp_def] at this
    convert this using 1
    norm_num
  exact h_sq

/-- Re[1/(Ïƒ + t*I - Ï)] â†’ +âˆ as Ïƒ â†’ Ï.re from right (when t = Ï.im). -/
theorem pole_real_part_tendsto_atTop (Ï : â„‚) :
    Tendsto (fun Ïƒ : â„ => ((Ïƒ : â„‚) + Ï.im * I - Ï)â»Â¹.re) (ğ“[>] Ï.re) atTop := by
  -- Re[1/(Ïƒ + t*I - Ï)] = (Ïƒ - Ï.re) / |Ïƒ + t*I - Ï|Â²
  -- When t = Ï.im, this = (Ïƒ - Ï.re) / (Ïƒ - Ï.re)Â² = 1/(Ïƒ - Ï.re) â†’ +âˆ
  have h_eq : âˆ€ Ïƒ : â„, Ïƒ â‰  Ï.re â†’
      ((Ïƒ : â„‚) + Ï.im * I - Ï)â»Â¹.re = (Ïƒ - Ï.re)â»Â¹ := by
    intro Ïƒ hÏƒ
    have h_sub : (Ïƒ : â„‚) + Ï.im * I - Ï = (Ïƒ - Ï.re : â„) := by
      apply Complex.ext <;> simp [sub_re, sub_im, ofReal_re, ofReal_im, mul_re, mul_im, I_re, I_im]
    rw [h_sub, â† ofReal_inv, ofReal_re]
  have h_tendsto : Tendsto (Â·â»Â¹) (ğ“[>] (0 : â„)) atTop := tendsto_inv_nhdsGT_zero
  have h_sub : Tendsto (fun Ïƒ => Ïƒ - Ï.re) (ğ“[>] Ï.re) (ğ“[>] 0) := by
    have h1 : Tendsto (fun Ïƒ => Ïƒ - Ï.re) (ğ“ Ï.re) (ğ“ 0) := by
      have := continuous_sub_right Ï.re |>.tendsto Ï.re
      simp only [sub_self] at this
      exact this
    refine tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _
      (h1.mono_left nhdsWithin_le_nhds) ?_
    filter_upwards [self_mem_nhdsWithin] with Ïƒ hÏƒ
    simp only [mem_Ioi] at hÏƒ
    exact sub_pos.mpr hÏƒ
  have h_inv := h_tendsto.comp h_sub
  have h_ev_eq : (fun Ïƒ : â„ => (Ïƒ - Ï.re)â»Â¹) =á¶ [ğ“[>] Ï.re]
      (fun Ïƒ : â„ => ((Ïƒ : â„‚) + Ï.im * I - Ï)â»Â¹.re) := by
    filter_upwards [self_mem_nhdsWithin] with Ïƒ hÏƒ
    have hÏƒ' : Ï.re < Ïƒ := hÏƒ
    exact (h_eq Ïƒ (ne_of_gt hÏƒ')).symm
  exact Tendsto.congr' h_ev_eq h_inv

/-!
## 3. Zeta Properties Near Zeros (Axiomatic)
-/

/-- Near a simple zero Ï, Î¶(s) â‰ˆ (s - Ï) * Î¶'(Ï) + higher order terms. -/
theorem zeta_taylor_at_zero (Ï : â„‚) (h_zero : riemannZeta Ï = 0)
    (h_not_one : Ï â‰  1) (h_simple : deriv riemannZeta Ï â‰  0) :
    âˆƒ (r : â„‚ â†’ â„‚), (âˆ€á¶  s in ğ“ Ï, riemannZeta s = (s - Ï) * deriv riemannZeta Ï +
      (s - Ï) ^ 2 * r s) âˆ§ ContinuousAt r Ï :=
  ProofEngine.ax_zeta_taylor_at_zero Ï h_zero h_not_one h_simple

/-- Log derivative near zero: Î¶'/Î¶(s) = 1/(s - Ï) + holomorphic. -/
theorem log_deriv_near_zero (Ï : â„‚) (h_zero : riemannZeta Ï = 0)
    (h_not_one : Ï â‰  1) (h_simple : deriv riemannZeta Ï â‰  0) :
    âˆƒ (h : â„‚ â†’ â„‚), DifferentiableAt â„‚ h Ï âˆ§
      âˆ€á¶  s in ğ“[â‰ ] Ï, deriv riemannZeta s / riemannZeta s = (s - Ï)â»Â¹ + h s :=
  ProofEngine.ax_log_deriv_near_zero Ï h_zero h_not_one h_simple

/-!
## 4. Pole Domination
-/

/-- The holomorphic part h(s) is bounded near Ï. -/
theorem holomorphic_part_bounded (Ï : â„‚) (h_zero : riemannZeta Ï = 0)
    (h_not_one : Ï â‰  1) (h_simple : deriv riemannZeta Ï â‰  0) :
    âˆƒ (C : â„) (Î´ : â„), 0 < C âˆ§ 0 < Î´ âˆ§
      âˆ€ s, â€–s - Ïâ€– < Î´ â†’ s â‰  Ï â†’
        â€–deriv riemannZeta s / riemannZeta s - (s - Ï)â»Â¹â€– â‰¤ C := by
  obtain âŸ¨h, h_diff, h_eqâŸ© := log_deriv_near_zero Ï h_zero h_not_one h_simple
  have h_cont : ContinuousAt h Ï := h_diff.continuousAt
  obtain âŸ¨Î´â‚, hÎ´â‚_pos, h_ballâŸ© := Metric.continuousAt_iff.mp h_cont 1 zero_lt_one
  let C := â€–h Ïâ€– + 1
  have hC_pos : 0 < C := by have := norm_nonneg (h Ï); linarith
  rw [Filter.Eventually, mem_nhdsWithin] at h_eq
  obtain âŸ¨t, ht_open, hÏ_mem, h_eq_onâŸ© := h_eq
  obtain âŸ¨Î´â‚‚, hÎ´â‚‚_pos, h_ballâ‚‚âŸ© := Metric.isOpen_iff.mp ht_open Ï hÏ_mem
  let Î´ := min Î´â‚ Î´â‚‚
  use C, Î´, hC_pos, lt_min hÎ´â‚_pos hÎ´â‚‚_pos
  intro s hs_dist hs_ne
  have hs_ballâ‚ : s âˆˆ Metric.ball Ï Î´â‚ := by
    rw [Metric.mem_ball, Complex.dist_eq]; exact lt_of_lt_of_le hs_dist (min_le_left _ _)
  have hs_ballâ‚‚ : s âˆˆ Metric.ball Ï Î´â‚‚ := by
    rw [Metric.mem_ball, Complex.dist_eq]; exact lt_of_lt_of_le hs_dist (min_le_right _ _)
  have hs_mem_t : s âˆˆ t := h_ballâ‚‚ hs_ballâ‚‚
  have h_formula := h_eq_on âŸ¨hs_mem_t, hs_neâŸ©
  rw [h_formula, add_sub_cancel_left]
  have h_norm := h_ball (Metric.mem_ball.mp hs_ballâ‚)
  rw [Complex.dist_eq] at h_norm
  calc â€–h sâ€– = â€–(h s - h Ï) + h Ïâ€– := by ring_nf
      _ â‰¤ â€–h s - h Ïâ€– + â€–h Ïâ€– := norm_add_le _ _
      _ â‰¤ C := by
        have : 1 + â€–h Ïâ€– = C := by simp [C, add_comm]
        linarith [h_norm]

/-- Axiom: The derivative of the log derivative (stiffness) tends to -âˆ near a zero. -/
axiom ax_analytic_stiffness_neg (Ï : â„‚) (h_zero : riemannZeta Ï = 0)
    (h_simple : deriv riemannZeta Ï â‰  0) (M : â„) :
    âˆƒ Î´ > 0, âˆ€ Ïƒ, Ï.re < Ïƒ â†’ Ïƒ < Ï.re + Î´ â†’
      (deriv (fun s => -(deriv riemannZeta s / riemannZeta s)) (Ïƒ + Ï.im * I)).re < -M

/-- Main theorem: Zeta zero implies clustering condition for sums.
    The weighted cosine sum becomes negative near zeros. -/
theorem zeta_zero_gives_negative_clustering (Ï : â„‚) (h_zero : riemannZeta Ï = 0)
    (h_strip : 0 < Ï.re âˆ§ Ï.re < 1) (h_simple : deriv riemannZeta Ï â‰  0)
    (primes : List â„•) (h_primes : âˆ€ p âˆˆ primes, Nat.Prime p)
    (h_large : primes.length > 1000) :
    âˆƒ Î´ > 0, âˆ€ Ïƒ âˆˆ Ioo (Ï.re) (Ï.re + Î´),
      primes.foldl (fun acc p =>
        acc + Real.log p * Real.log p * (p : â„) ^ (-Ïƒ) * Real.cos (Ï.im * Real.log p)) 0 < 0 := by
  have h_not_one : Ï â‰  1 := by
    intro h_eq; rw [h_eq] at h_strip; simp only [one_re] at h_strip; linarith [h_strip.2]
  obtain âŸ¨E, h_approxâŸ© := ProofEngine.ax_finite_sum_approx_analytic Ï primes
  let M := |E| + 1
  obtain âŸ¨Î´, hÎ´, h_stiffâŸ© := ax_analytic_stiffness_neg Ï h_zero h_simple M
  use Î´, hÎ´
  intro Ïƒ hÏƒ
  let Finite := primes.foldl (fun acc p =>
        acc + Real.log p * Real.log p * (p : â„) ^ (-Ïƒ) * Real.cos (Ï.im * Real.log p)) 0
  let Analytic := (deriv (fun s => -(deriv riemannZeta s / riemannZeta s)) (Ïƒ + Ï.im * I)).re
  have h_anal_val : Analytic < -M := h_stiff Ïƒ hÏƒ.1 hÏƒ.2
  have h_err := h_approx Ïƒ
  have h_E_pos : 0 < E := by
    have := abs_nonneg (Finite - Analytic)
    linarith [h_err]
  have h1 : Finite < Analytic + E := by rw [abs_lt] at h_err; linarith
  have h2 : Analytic + E < -M + E := by linarith
  have h3 : -M + E = -1 := by
    simp only [M]
    rw [abs_of_pos h_E_pos]
    ring
  calc Finite < Analytic + E := h1
    _ < -M + E := h2
    _ = -1 := h3
    _ < 0 := by norm_num

end ProofEngine.Residues

end