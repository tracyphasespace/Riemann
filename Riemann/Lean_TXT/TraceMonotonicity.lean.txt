/-
# Trace Monotonicity: The Gradient Force in Cl(3,3)

**Physical Interpretation**:
The Scalar Trace T(Ïƒ) acts as the **Gradient Force**.
The "Pole" is a region of high Bivector Torque.
The phases Î¸ = tÂ·log(p) align such that the weighted cosine sum S is NEGATIVE.
This alignment forces the Scalar Derivative T' to be POSITIVE.

**Mechanism**:
Let S(Ïƒ) = Î£ (log p)Â² Â· p^{-Ïƒ} Â· cos(t Â· log p)

Then T'(Ïƒ) = -2 Â· S(Ïƒ)

If S(Ïƒ) < 0 (Negative Phase Clustering / Inward Compression), then:
  T'(Ïƒ) = -2 Â· (negative) = POSITIVE
  Therefore T is strictly INCREASING

This matches the observed plot where T(Ïƒ) climbs from â‰ˆ -50 to â‰ˆ -7.

## Cl(3,3) Proof Toolbox: Strict Monotonicity

### Tool 4: Strict Monotonicity from Positive Derivative (MVT)

The key theorem `negative_clustering_implies_monotonicity` uses:
```
(âˆ€ x âˆˆ (a,b), f'(x) > 0) âŸ¹ StrictMonoOn f (a,b)
```

**Implementation** (from Mathlib):
```lean
apply strictMonoOn_of_deriv_pos (convex_Ioo 0 1)
Â· -- Continuity: continuous_rotorTrace
Â· -- Positive derivative: negative_clustering_implies_positive_deriv
```

**Cl(3,3) Meaning**:
- Negative Phase Clustering (S < 0) âŸ¹ Positive Force (T' > 0)
- Positive Force âŸ¹ Strictly Increasing Trace
- Strictly Increasing âŸ¹ Unique Equilibrium (at most one zero crossing)

**Status**: The MVT application is complete. Sorries remain for:
- `hasDerivAt_rotorTrace`: List induction + HasDerivAt.add (technical coercion issue)
- `continuous_rotorTrace`: Similar List coercion issue
-/

import Riemann.ZetaSurface.CliffordRH
import Mathlib.Analysis.Calculus.MeanValue
import Mathlib.Analysis.Calculus.Deriv.Basic
import Mathlib.Analysis.SpecialFunctions.Pow.Deriv
import Mathlib.Analysis.SpecialFunctions.ExpDeriv
import Mathlib.Analysis.Calculus.Deriv.Add
import Mathlib.Analysis.Calculus.Deriv.Mul
import Mathlib.Analysis.Convex.Deriv
import Mathlib.Order.Monotone.Basic

open CliffordRH Real Set

noncomputable section

namespace TraceMonotonicity

/-!
## 1. The Phase-Locking Hypothesis (Geometric Alignment)
-/

/--
**Hypothesis: Inward Phase Locking (Negative Phase Clustering)**

The geometry of the Prime Sieve aligns such that the weighted cosine sum is NEGATIVE.
This corresponds to "Compression" in the Cl(3,3) manifold.

Numerically verified for t > 20 at zeta zeros.
-/
def NegativePhaseClustering (Ïƒ t : â„) (primes : List â„•) : Prop :=
  primes.foldl (fun (acc : â„) (p : â„•) =>
    acc + (Real.log p)^2 * (p : â„)^(-Ïƒ) * Real.cos (t * Real.log p)) 0 < 0

/-!
## 2. The Derivative Formula
-/

/--
**The First Derivative in terms of the clustering sum**

T'(Ïƒ) = rotorTraceFirstDeriv Ïƒ t primes = -2 Â· S(Ïƒ)
where S(Ïƒ) = Î£ (log p)Â² Â· p^{-Ïƒ} Â· cos(t Â· log p)
-/
theorem firstDeriv_eq_neg_two_sum (Ïƒ t : â„) (primes : List â„•) :
    rotorTraceFirstDeriv Ïƒ t primes =
    -2 * primes.foldl (fun (acc : â„) (p : â„•) =>
      acc + (Real.log p)^2 * (p : â„)^(-Ïƒ) * Real.cos (t * Real.log p)) 0 := by
  rfl

/-!
## 3. Negative Clustering Implies Positive Derivative
-/

/--
**Key Lemma: Negative Sum âŸ¹ Positive Derivative**

If Î£ (log p)Â² Â· p^{-Ïƒ} Â· cos(t Â· log p) < 0, then T'(Ïƒ) > 0.

In Cl(3,3): -2 * (Negative Compression) = Positive Force
-/
theorem negative_clustering_implies_positive_deriv (Ïƒ t : â„) (primes : List â„•)
    (h_neg : NegativePhaseClustering Ïƒ t primes) :
    rotorTraceFirstDeriv Ïƒ t primes > 0 := by
  unfold NegativePhaseClustering at h_neg
  rw [firstDeriv_eq_neg_two_sum]
  -- We have: -2 * (negative number)
  -- Since the sum < 0, and -2 < 0, the product is positive
  nlinarith

/-!
## 4. Connecting HasDerivAt to Monotonicity
-/

/--
**Helper Lemma**: The function Ïƒ â†¦ p^{-Ïƒ} is differentiable for p > 0.
This uses the fact that p^{-Ïƒ} = exp(-Ïƒ Â· log p).
-/
theorem differentiable_rpow_neg (p : â„) (hp : 0 < p) :
    Differentiable â„ (fun (Ïƒ : â„) => p ^ (-Ïƒ)) := by
  -- p^{-Ïƒ} = exp(-Ïƒ * log p)
  have h_eq : (fun (Ïƒ : â„) => p ^ (-Ïƒ)) = (fun Ïƒ => Real.exp (-Ïƒ * Real.log p)) := by
    ext Ïƒ
    rw [Real.rpow_def_of_pos hp]
    ring_nf
  rw [h_eq]
  -- -Ïƒ * log p is differentiable, so exp(-Ïƒ * log p) is differentiable
  apply Differentiable.exp
  exact (differentiable_id (ğ•œ := â„)).neg.mul_const (Real.log p)

/--
**Helper**: A single term log(p) Â· p^{-Ïƒ} Â· cos(tÂ·log p) is differentiable in Ïƒ.
-/
theorem differentiable_term (p : â„•) (t : â„) (hp : 0 < (p : â„)) :
    Differentiable â„ (fun (Ïƒ : â„) => Real.log p * (p : â„) ^ (-Ïƒ) * Real.cos (t * Real.log p)) := by
  -- The only Ïƒ-dependent part is (p : â„) ^ (-Ïƒ)
  -- log p and cos(...) are constants w.r.t. Ïƒ
  have h_diff : Differentiable â„ (fun (Ïƒ : â„) => (p : â„) ^ (-Ïƒ)) :=
    differentiable_rpow_neg (p : â„) hp
  exact ((differentiable_const _).mul h_diff).mul (differentiable_const _)

/--
**Helper**: The derivative of p^{-Ïƒ} with respect to Ïƒ is -log(p) Â· p^{-Ïƒ}.
-/
theorem hasDerivAt_rpow_neg (p : â„) (Ïƒ : â„) (hp : 0 < p) :
    HasDerivAt (fun Ïƒ' => p ^ (-Ïƒ')) (-Real.log p * p ^ (-Ïƒ)) Ïƒ := by
  -- p^{-Ïƒ} = exp(-Ïƒ * log p)
  -- d/dÏƒ[exp(-Ïƒ * log p)] = -log p * exp(-Ïƒ * log p)
  have h_eq : âˆ€ Ïƒ', p ^ (-Ïƒ') = Real.exp (-Ïƒ' * Real.log p) := by
    intro Ïƒ'
    rw [Real.rpow_def_of_pos hp]
    ring_nf
  have h1 : HasDerivAt (fun Ïƒ' => Real.exp (-Ïƒ' * Real.log p))
                       (-Real.log p * Real.exp (-Ïƒ * Real.log p)) Ïƒ := by
    have h_inner : HasDerivAt (fun Ïƒ' => -Ïƒ' * Real.log p) (-Real.log p) Ïƒ := by
      convert (hasDerivAt_neg Ïƒ).mul_const (Real.log p) using 1
      ring
    convert (Real.hasDerivAt_exp (-Ïƒ * Real.log p)).comp Ïƒ h_inner using 1
    ring
  convert h1 using 2 <;> exact h_eq _

/--
**Helper**: The derivative of log(p) Â· p^{-Ïƒ} Â· cos(...) with respect to Ïƒ.
d/dÏƒ[log(p) Â· p^{-Ïƒ} Â· cos] = -log(p)Â² Â· p^{-Ïƒ} Â· cos
-/
theorem hasDerivAt_term (p : â„•) (t Ïƒ : â„) (hp : 0 < (p : â„)) :
    HasDerivAt (fun Ïƒ' => Real.log p * (p : â„) ^ (-Ïƒ') * Real.cos (t * Real.log p))
               (-(Real.log p)^2 * (p : â„) ^ (-Ïƒ) * Real.cos (t * Real.log p)) Ïƒ := by
  -- Apply product rule: d/dÏƒ[câ‚ Â· f(Ïƒ) Â· câ‚‚] = câ‚ Â· câ‚‚ Â· f'(Ïƒ)
  have h1 := hasDerivAt_rpow_neg (p : â„) Ïƒ hp
  have h2 := h1.const_mul (Real.log p)
  have h3 := h2.mul_const (Real.cos (t * Real.log p))
  convert h3 using 1
  ring

/-- Helper: foldl with addition and initial value a equals a + foldl with initial 0 -/
theorem foldl_add_init_generic {Î± : Type} (l : List Î±) (f : Î± â†’ â„) (a : â„) :
    l.foldl (fun acc x => acc + f x) a = a + l.foldl (fun acc x => acc + f x) 0 := by
  induction l generalizing a with
  | nil => simp
  | cons h t ih =>
    simp only [List.foldl_cons, zero_add]
    rw [ih (a + f h), ih (f h)]
    ring

lemma foldl_add_neg_eq_neg_foldl (l : List â„•) (f : â„• â†’ â„) :
    l.foldl (fun acc p => acc + -(f p)) 0 = -l.foldl (fun acc p => acc + f p) 0 := by
  induction l with
  | nil => simp
  | cons p ps ih =>
    simp only [List.foldl_cons, zero_add]
    -- LHS: foldl (... -f ...) (-(f p)) ps = -(f p) + foldl (... -f ...) 0 ps
    rw [foldl_add_init_generic (l := ps) (f := fun q => -(f q)) (a := -(f p))]
    -- RHS: -foldl (... f ...) (f p) ps = -(f p + foldl (... f ...) 0 ps)
    rw [foldl_add_init_generic (l := ps) (f := f) (a := f p)]
    rw [ih]
    ring

/--
The trace function has derivative equal to rotorTraceFirstDeriv.

**Mathematical content** (clear):
- d/dÏƒ [Î£ term(p)] = Î£ d/dÏƒ[term(p)] by linearity of differentiation
- Each term has derivative given by `hasDerivAt_term`
- The sum of derivatives equals `rotorTraceFirstDeriv`

**Technical issue** (Lean 4 coercion):
- The foldl over `List â„•` creates a coercion `do let a â† primes; pure â†‘a`
- This syntactic representation doesn't match direct `List.foldl_cons` rewrites
- The sorry is purely about Lean 4's coercion machinery, not mathematics
-/
theorem hasDerivAt_rotorTrace (Ïƒ t : â„) (primes : List â„•)
    (h_primes : âˆ€ p âˆˆ primes, 0 < (p : â„)) :
    HasDerivAt (fun Ïƒ' => rotorTrace Ïƒ' t primes)
               (rotorTraceFirstDeriv Ïƒ t primes) Ïƒ := by
  -- Proof structure:
  -- 1. The trace is 2 * Î£ log(p) * p^{-Ïƒ} * cos(t*log(p))
  -- 2. Each term has derivative -(log(p))Â² * p^{-Ïƒ} * cos(...) by hasDerivAt_term
  -- 3. The sum of derivatives is Î£ (-(log(p))Â² * ...)
  -- 4. Factoring: 2 * Î£ (-(log(p))Â² * ...) = -2 * Î£ ((log(p))Â² * ...) = rotorTraceFirstDeriv
  --
  -- The technical challenge is showing HasDerivAt for the foldl sum.
  -- By induction on primes:
  --   Base: foldl of [] has derivative 0 (constant 0)
  --   Step: foldl of (p::ps) = term(p) + foldl(ps)
  --         HasDerivAt for sum = HasDerivAt.add of term and tail
  --
  -- Each hasDerivAt_term p t Ïƒ hp gives the derivative of the p-term.
  -- HasDerivAt.add combines them inductively.
  -- Finally, const_mul 2 gives the full derivative.
  unfold rotorTrace rotorTraceFirstDeriv
  let term : â„• â†’ â„ â†’ â„ :=
    fun p Ïƒ' => Real.log p * (p : â„) ^ (-Ïƒ') * Real.cos (t * Real.log p)
  let f : â„• â†’ â„ :=
    fun p => (Real.log p) ^ 2 * (p : â„) ^ (-Ïƒ) * Real.cos (t * Real.log p)
  let dterm : â„• â†’ â„ := fun p => -f p
  have h_foldl :
      HasDerivAt (fun Ïƒ' => primes.foldl (fun (acc : â„) (p : â„•) => acc + term p Ïƒ') 0)
                 (primes.foldl (fun (acc : â„) (p : â„•) => acc + dterm p) 0) Ïƒ := by
    induction primes with
    | nil =>
        simp only [List.foldl_nil]
        exact hasDerivAt_const Ïƒ 0
    | cons p ps ih =>
        have hp_pos : 0 < (p : â„) := h_primes p (List.mem_cons.mpr (Or.inl rfl))
        have h_term : HasDerivAt (fun Ïƒ' => term p Ïƒ') (dterm p) Ïƒ := by
          simpa [term, dterm, f] using hasDerivAt_term p t Ïƒ hp_pos
        have h_tail :
            HasDerivAt (fun Ïƒ' => ps.foldl (fun (acc : â„) (q : â„•) => acc + term q Ïƒ') 0)
                       (ps.foldl (fun (acc : â„) (q : â„•) => acc + dterm q) 0) Ïƒ :=
          ih (fun q hq => h_primes q (List.mem_cons_of_mem p hq))
        have h_sum := h_term.add h_tail
        -- Rewrite the foldl form to match the sum form.
        refine (by
          convert h_sum using 1
          Â· funext Ïƒ'
            calc
              (p :: ps).foldl (fun (acc : â„) (q : â„•) => acc + term q Ïƒ') 0
                  = ps.foldl (fun (acc : â„) (q : â„•) => acc + term q Ïƒ') (term p Ïƒ') := by
                      simp [List.foldl_cons, term]
              _ = term p Ïƒ' +
                  ps.foldl (fun (acc : â„) (q : â„•) => acc + term q Ïƒ') 0 := by
                      simpa [term] using
                        (foldl_add_init_generic (l := ps) (f := fun q => term q Ïƒ')
                          (a := term p Ïƒ'))
          Â· calc
              (p :: ps).foldl (fun (acc : â„) (q : â„•) => acc + dterm q) 0
                  = ps.foldl (fun (acc : â„) (q : â„•) => acc + dterm q) (dterm p) := by
                      simp [List.foldl_cons]
              _ = dterm p + ps.foldl (fun (acc : â„) (q : â„•) => acc + dterm q) 0 := by
                      simpa using
                        (foldl_add_init_generic (l := ps) (f := fun q => dterm q) (a := dterm p))
        )
  -- The derivative computation follows from linearity.
  have h_scale :
      HasDerivAt (fun Ïƒ' =>
        2 * primes.foldl (fun (acc : â„) (p : â„•) => acc + term p Ïƒ') 0)
        (2 * primes.foldl (fun (acc : â„) (p : â„•) => acc + dterm p) 0) Ïƒ :=
    h_foldl.const_mul 2
  have h_neg :
      2 * primes.foldl (fun (acc : â„) (p : â„•) => acc + dterm p) 0 =
        -(2 * primes.foldl (fun (acc : â„) (p : â„•) => acc + f p) 0) := by
    have h_foldl_neg :
        primes.foldl (fun (acc : â„) (p : â„•) => acc + dterm p) 0 =
          -primes.foldl (fun (acc : â„) (p : â„•) => acc + f p) 0 := by
      simpa [dterm] using (foldl_add_neg_eq_neg_foldl primes f)
    calc
      2 * primes.foldl (fun (acc : â„) (p : â„•) => acc + dterm p) 0
          = 2 * (-primes.foldl (fun (acc : â„) (p : â„•) => acc + f p) 0) := by
              simp [h_foldl_neg]
      _ = -(2 * primes.foldl (fun (acc : â„) (p : â„•) => acc + f p) 0) := by ring
  simpa [rotorTrace, term, h_neg] using h_scale

/--
**Helper**: A single term is continuous in Ïƒ.
-/
theorem continuous_term (p : â„•) (t : â„) (hp : 0 < (p : â„)) :
    Continuous (fun (Ïƒ : â„) => Real.log p * (p : â„) ^ (-Ïƒ) * Real.cos (t * Real.log p)) := by
  -- Continuity follows from differentiability
  exact (differentiable_term p t hp).continuous

/-- Helper: foldl with addition and initial value a equals a + foldl with initial 0 -/
theorem foldl_add_init (t : â„) (l : List â„•) (a : â„) (Ïƒ : â„) :
    l.foldl (fun (acc : â„) (p : â„•) =>
      acc + Real.log p * (p : â„) ^ (-Ïƒ) * Real.cos (t * Real.log p)) a =
    a + l.foldl (fun (acc : â„) (p : â„•) =>
      acc + Real.log p * (p : â„) ^ (-Ïƒ) * Real.cos (t * Real.log p)) 0 := by
  simpa using
    (foldl_add_init_generic l
      (fun p => Real.log p * (p : â„) ^ (-Ïƒ) * Real.cos (t * Real.log p)) a)

/--
The trace function is continuous.

**Mathematical content** (clear):
- Each term log(p) * p^{-Ïƒ} * cos(t*log(p)) is continuous by `continuous_term`
- A finite sum of continuous functions is continuous
- Therefore rotorTrace = 2 * Î£ term(p) is continuous

**Technical issue** (Lean 4 coercion):
- Same as `hasDerivAt_rotorTrace`: the foldl coercion syntax doesn't match
- The sorry is purely about Lean 4's `do let a â† l; pure â†‘a` representation
-/
theorem continuous_rotorTrace (t : â„) (primes : List â„•)
    (h_primes : âˆ€ p âˆˆ primes, 0 < (p : â„)) :
    Continuous (fun Ïƒ => rotorTrace Ïƒ t primes) := by
  -- The trace is 2 * (sum of terms), so continuous if the sum is continuous
  unfold rotorTrace
  apply Continuous.mul continuous_const
  let term : â„• â†’ â„ â†’ â„ :=
    fun p Ïƒ' => Real.log p * (p : â„) ^ (-Ïƒ') * Real.cos (t * Real.log p)
  -- Each term continuous_term p t hp shows log(p)*p^{-Ïƒ}*cos(...) is continuous
  -- The foldl is a finite iteration of continuous additions
  -- By induction, each partial sum is continuous
  induction primes with
  | nil => exact continuous_const
  | cons p ps ih =>
    have hp_pos : 0 < (p : â„) := h_primes p (List.mem_cons.mpr (Or.inl rfl))
    have h_term : Continuous (fun Ïƒ => term p Ïƒ) := by
      simpa [term] using continuous_term p t hp_pos
    have h_tail := ih (fun q hq => h_primes q (List.mem_cons_of_mem p hq))
    -- Goal: Continuous fun Ïƒ => foldl f 0 (p::ps)
    -- We have:
    --   h_term: Continuous (fun Ïƒ => log p * p^(-Ïƒ) * cos(...))
    --   h_tail: Continuous (fun Ïƒ => foldl f 0 ps)
    --   h_sum:  Continuous (fun Ïƒ => term(p,Ïƒ) + foldl f 0 ps)
    -- The goal is the same function by foldl definition, but Lean's coercion
    -- representation `do let a â† l; pure â†‘a` differs syntactically.
    -- This is a definitional equality that simp/rfl don't handle automatically.
    have h_sum := h_term.add h_tail
    have h_fun :
        (fun Ïƒ =>
          term p Ïƒ + ps.foldl (fun (acc : â„) (q : â„•) => acc + term q Ïƒ) 0) =
        (fun Ïƒ =>
          (p :: ps).foldl (fun (acc : â„) (q : â„•) => acc + term q Ïƒ) 0) := by
      funext Ïƒ
      calc
        term p Ïƒ + ps.foldl (fun (acc : â„) (q : â„•) => acc + term q Ïƒ) 0
            = ps.foldl (fun (acc : â„) (q : â„•) => acc + term q Ïƒ) (term p Ïƒ) := by
                simpa [term] using
                  (foldl_add_init_generic (l := ps) (f := fun q => term q Ïƒ) (a := term p Ïƒ)).symm
        _ = (p :: ps).foldl (fun (acc : â„) (q : â„•) => acc + term q Ïƒ) 0 := by
                simp [List.foldl_cons, term]
    refine (Continuous.congr h_sum ?_)
    intro Ïƒ
    simpa using congrArg (fun f => f Ïƒ) h_fun

/-!
## 5. The Main Theorem: Phase Clustering âŸ¹ Monotonicity
-/

/--
**Main Theorem: Negative Clustering Implies Strict Monotonicity**

If âˆ€ Ïƒ âˆˆ (0,1), the weighted cosine sum is negative (phase clustering),
then the trace T(Ïƒ) is strictly increasing on (0,1).

This is a property of the Cl(3,3) manifold geometry, not an analytic trick.
-/
theorem negative_clustering_implies_monotonicity (t : â„) (primes : List â„•)
    (h_primes : âˆ€ p âˆˆ primes, 0 < (p : â„))
    (h_cluster : âˆ€ Ïƒ, Ïƒ âˆˆ Ioo 0 1 â†’ NegativePhaseClustering Ïƒ t primes) :
    TraceIsMonotonic t primes := by
  rw [TraceIsMonotonic]
  -- Use: f' > 0 on (a,b) implies f is strictly increasing on [a,b]
  -- This is the Mean Value Theorem consequence
  apply strictMonoOn_of_deriv_pos (convex_Ioo 0 1)
  Â· -- Continuity on the interval
    exact (continuous_rotorTrace t primes h_primes).continuousOn
  Â· -- Derivative is positive on the interior
    intro Ïƒ hÏƒ
    -- interior of Ioo is Ioo itself
    rw [interior_Ioo] at hÏƒ
    -- Get the derivative at Ïƒ
    have h_deriv := hasDerivAt_rotorTrace Ïƒ t primes h_primes
    rw [HasDerivAt.deriv h_deriv]
    -- Apply positive derivative from negative clustering
    exact negative_clustering_implies_positive_deriv Ïƒ t primes (h_cluster Ïƒ hÏƒ)

/-!
## 6. Uniqueness of Equilibrium
-/

/--
**Geometric Stability Lemma**

If T(Ïƒ) is strictly monotonic, then for any value c,
the set {Ïƒ âˆˆ (0,1) | T(Ïƒ) = c} has at most one element.

A strictly monotonic function can cross any value at most once.
This guarantees uniqueness of zeros/equilibria.
-/
theorem monotonicity_implies_unique_preimage (t : â„) (primes : List â„•) (c : â„)
    (h_mono : TraceIsMonotonic t primes) :
    Set.Subsingleton {Ïƒ | Ïƒ âˆˆ Ioo 0 1 âˆ§ rotorTrace Ïƒ t primes = c} := by
  intro Ïƒâ‚ hÏƒâ‚ Ïƒâ‚‚ hÏƒâ‚‚
  by_contra h_ne
  rw [TraceIsMonotonic] at h_mono
  -- Two distinct points with same value contradicts strict monotonicity
  rcases lt_trichotomy Ïƒâ‚ Ïƒâ‚‚ with h_lt | h_eq | h_gt
  Â· -- Ïƒâ‚ < Ïƒâ‚‚
    have h_strict := h_mono hÏƒâ‚.1 hÏƒâ‚‚.1 h_lt
    -- h_strict : T(Ïƒâ‚) < T(Ïƒâ‚‚), but both equal c
    simp only [hÏƒâ‚.2, hÏƒâ‚‚.2] at h_strict
    exact lt_irrefl c h_strict
  Â· exact h_ne h_eq
  Â· -- Ïƒâ‚‚ < Ïƒâ‚
    have h_strict := h_mono hÏƒâ‚‚.1 hÏƒâ‚.1 h_gt
    simp only [hÏƒâ‚.2, hÏƒâ‚‚.2] at h_strict
    exact lt_irrefl c h_strict

/-!
## 7. Summary

1. **Observation**: T(Ïƒ) is numerically seen to be NEGATIVE and INCREASING
2. **Hypothesis**: Negative Phase Clustering (sum of weighted cosines < 0)
3. **Algebra**: T' = -2 Ã— (negative sum) = positive
4. **Calculus**: Positive derivative âŸ¹ strictly increasing
5. **Geometry**: Strictly increasing âŸ¹ unique equilibrium

The key insight is that the trace is the "force" (gradient).
The "energy well" (norm) is what minimizes at Ïƒ = 1/2.
-/

end TraceMonotonicity

end
