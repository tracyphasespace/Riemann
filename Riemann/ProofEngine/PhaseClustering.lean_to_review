import Riemann.ZetaSurface.CliffordRH
import Riemann.ZetaSurface.TraceMonotonicity
import Mathlib.NumberTheory.LSeries.RiemannZeta
import Mathlib.Analysis.Complex.Basic
import Mathlib.Analysis.Meromorphic.Basic
import Mathlib.Analysis.Calculus.Deriv.Basic
import Mathlib.Topology.Algebra.Order.Field
import Riemann.ProofEngine.Residues
import Riemann.ProofEngine.AnalyticBasics

open Complex Real Filter Topology BigOperators TraceMonotonicity
open ProofEngine.AnalyticBasics ProofEngine.Residues

noncomputable section

namespace ProofEngine.PhaseClustering

/-!
## Local filter arithmetic helpers

This file needs two standard pieces of "limit arithmetic":

* if `f â†’ -âˆ` (i.e. `atBot`) and `g` is eventually bounded above, then `f + g â†’ -âˆ`.
* if `f â†’ -âˆ` then `-f â†’ +âˆ`.

Mathlib has various lemmas for this, but keeping explicit helper lemmas here
makes the proof robust against minor library refactors.
-/

lemma tendsto_atBot_add_of_tendsto_atBot_of_eventually_le
    {Î± : Type} {l : Filter Î±} {f g : Î± â†’ â„} {C : â„}
    (hf : Tendsto f l atBot) (hg : âˆ€á¶  x in l, g x â‰¤ C) :
    Tendsto (fun x => f x + g x) l atBot := by
  -- Characterization of `Tendsto _ _ atBot` on `â„`.
  refine (tendsto_atBot.2 ?_)
  intro a
  have hf' : âˆ€á¶  x in l, f x â‰¤ a - C := (tendsto_atBot.1 hf) (a - C)
  filter_upwards [hf', hg] with x hfx hgx
  linarith

lemma tendsto_atBot_add_of_tendsto_atBot_of_tendsto
    {Î± : Type} {l : Filter Î±} {f g : Î± â†’ â„} {c : â„}
    (hf : Tendsto f l atBot) (hg : Tendsto g l (ğ“ c)) :
    Tendsto (fun x => f x + g x) l atBot := by
  -- From convergence we get an eventual upper bound.
  have hg_bd : âˆ€á¶  x in l, g x â‰¤ c + 1 := by
    have hnhds : âˆ€á¶  y in ğ“ c, y âˆˆ Set.Icc (c - 1) (c + 1) := by
      -- Closed intervals are neighborhoods of interior points.
      simpa using (Icc_mem_nhds (by linarith : c - 1 < c) (by linarith : c < c + 1))
    have : âˆ€á¶  x in l, g x âˆˆ Set.Icc (c - 1) (c + 1) := hg.eventually hnhds
    filter_upwards [this] with x hx
    exact hx.2
  exact tendsto_atBot_add_of_tendsto_atBot_of_eventually_le hf hg_bd

/-!
## 1. The Analytic Machinery: Pole of Î¶'/Î¶
Instead of axioms, we use the rigorously proven `log_deriv_zeta_near_zero`
from `AnalyticBasics.lean`, which establishes that Î¶'/Î¶ has a simple pole.
-/

/--
**Helper Lemma**: Standard limit -1/x â†’ -âˆ as x â†’ 0âº.
-/
theorem tendsto_neg_inv_nhdsGT_zero :
    Tendsto (fun x : â„ => -xâ»Â¹) (ğ“[>] (0 : â„)) atBot := by
  have h1 : Tendsto (fun x : â„ => xâ»Â¹) (ğ“[>] (0 : â„)) atTop :=
    tendsto_inv_nhdsGT_zero
  have h2 : Tendsto (fun y : â„ => -y) atTop atBot :=
    tendsto_neg_atTop_atBot
  exact h2.comp h1

/--
**Helper Lemma**: Translation of the limit to zâ‚€.re.
-/
theorem tendsto_neg_inv_sub_nhdsGT (xâ‚€ : â„) :
    Tendsto (fun x : â„ => -(x - xâ‚€)â»Â¹) (ğ“[>] xâ‚€) atBot := by
  have h_sub : Tendsto (fun Ïƒ => Ïƒ - xâ‚€) (ğ“[>] xâ‚€) (ğ“[>] 0) := by
    have h1 : Tendsto (fun Ïƒ => Ïƒ - xâ‚€) (ğ“ xâ‚€) (ğ“ 0) := by
      have := continuous_sub_right xâ‚€ |>.tendsto xâ‚€
      simp only [sub_self] at this
      exact this
    have h2 : Tendsto (fun Ïƒ => Ïƒ - xâ‚€) (ğ“[>] xâ‚€) (ğ“ 0) :=
      h1.mono_left nhdsWithin_le_nhds
    refine tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ h2 ?_
    filter_upwards [self_mem_nhdsWithin] with Ïƒ hÏƒ
    simp only [Set.mem_Ioi] at hÏƒ âŠ¢
    linarith
  have h_inv := tendsto_neg_inv_nhdsGT_zero.comp h_sub
  simp only [Function.comp_def] at h_inv âŠ¢
  exact h_inv

/--
**Theorem: Divergence of the Negative Log Derivative**
For a simple zero Ï, the real part of -Î¶'/Î¶ diverges to -âˆ on the horizontal approach.

Proof:
Î¶'/Î¶ â‰ˆ 1/(s-Ï) + h(s)
-Î¶'/Î¶ â‰ˆ -1/(s-Ï) - h(s)
On the line s = Ïƒ + iÏ.im, (s-Ï) = Ïƒ - Ï.re.
As Ïƒ â†’ Ï.reâº, 1/(Ïƒ-Ï.re) â†’ +âˆ, so the negative goes to -âˆ.
-/
theorem log_deriv_neg_divergence_at_zero (Ï : â„‚)
    (h_zero : riemannZeta Ï = 0) (h_not_one : Ï â‰  1) (h_simple : deriv riemannZeta Ï â‰  0) :
    Tendsto (fun Ïƒ : â„ => (-(deriv riemannZeta (Ïƒ + Ï.im * I) / riemannZeta (Ïƒ + Ï.im * I))).re)
      (ğ“[>] Ï.re) atBot := by

  -- 1. Get the pole structure: Î¶'/Î¶ = 1/(s-Ï) + h
  obtain âŸ¨h, h_diff, h_eqâŸ© := log_deriv_zeta_near_zero Ï h_zero h_not_one h_simple

  -- 2. On the line, Re(1/(s-Ï)) = 1/(Ïƒ-Ï.re)
  have h_pole_lim := pole_real_part_tendsto_atTop Ï

  -- 3. We want the limit of the NEGATIVE, so it goes to atBot
  have h_neg_pole : Tendsto (fun Ïƒ : â„ => -((Ïƒ : â„‚) + Ï.im * I - Ï)â»Â¹.re) (ğ“[>] Ï.re) atBot :=
    tendsto_neg_atTop_atBot.comp h_pole_lim

  -- 4. Bounded background h(s) does not affect divergence to infinity
  -- (Standard Filter/Limit Arithmetic: -âˆ + Bounded = -âˆ)
  -- We first put the pole decomposition on the horizontal line.
  have hz : Tendsto (fun Ïƒ : â„ => (Ïƒ : â„‚) + Ï.im * Complex.I) (ğ“[>] Ï.re) (ğ“ Ï) := by
    have hcont : ContinuousAt (fun Ïƒ : â„ => (Ïƒ : â„‚) + Ï.im * Complex.I) Ï.re := by
      -- `Ïƒ â†¦ (Ïƒ : â„‚)` is continuous and we add a constant imaginary part.
      simpa using (Complex.continuous_ofReal.continuousAt.add (continuousAt_const))
    -- Approach from the right is a within-filter of the usual neighborhood.
    -- Convert the target point `(Ï.re : â„‚) + Ï.im * I` to `Ï`.
    simpa [Complex.re_add_im] using hcont.tendsto_nhdsWithin

  -- The analytic remainder converges along the same approach, hence is (eventually) bounded above.
  have h_rem_tendsto :
      Tendsto (fun Ïƒ : â„ => (-(h ((Ïƒ : â„‚) + Ï.im * Complex.I))).re)
        (ğ“[>] Ï.re) (ğ“ (-(h Ï)).re) := by
    have hh : Tendsto h (ğ“ Ï) (ğ“ (h Ï)) := h_diff.continuousAt.tendsto
    have hh_line : Tendsto (fun Ïƒ : â„ => h ((Ïƒ : â„‚) + Ï.im * Complex.I)) (ğ“[>] Ï.re) (ğ“ (h Ï)) :=
      hh.comp hz
    have hh_line_neg : Tendsto (fun Ïƒ : â„ => -(h ((Ïƒ : â„‚) + Ï.im * Complex.I))) (ğ“[>] Ï.re) (ğ“ (-h Ï)) :=
      hh_line.neg
    have hre : Tendsto (fun z : â„‚ => z.re) (ğ“ (-h Ï)) (ğ“ ((-h Ï).re)) :=
      (Complex.continuous_re.continuousAt).tendsto
    exact hre.comp hh_line_neg

  -- Now rewrite `-(Î¶'/Î¶)` using the local pole decomposition.
  have h_eq_line :
      âˆ€á¶  Ïƒ in ğ“[>] Ï.re,
        deriv riemannZeta ((Ïƒ : â„‚) + Ï.im * I) / riemannZeta ((Ïƒ : â„‚) + Ï.im * I)
          = (((Ïƒ : â„‚) + Ï.im * I) - Ï)â»Â¹ + h (((Ïƒ : â„‚) + Ï.im * I)) := by
    exact hz.eventually h_eq

  have h_congr :
      (fun Ïƒ : â„ => (-(deriv riemannZeta (Ïƒ + Ï.im * I) / riemannZeta (Ïƒ + Ï.im * I))).re)
        =á¶ [ğ“[>] Ï.re]
      (fun Ïƒ : â„ =>
        (-(((Ïƒ : â„‚) + Ï.im * I - Ï)â»Â¹).re) + (-(h ((Ïƒ : â„‚) + Ï.im * I))).re) := by
    filter_upwards [h_eq_line] with Ïƒ hÏƒ
    -- Real-part linearity and the pole decomposition.
    -- `simp` handles `Complex.add_re` and `neg_add`.
    simp [hÏƒ, Complex.add_re, add_assoc, add_left_comm, add_comm]

  -- Combine the divergent pole term with the convergent remainder.
  have h_sum :
      Tendsto
        (fun Ïƒ : â„ => (-(((Ïƒ : â„‚) + Ï.im * I - Ï)â»Â¹).re) + (-(h ((Ïƒ : â„‚) + Ï.im * I))).re)
        (ğ“[>] Ï.re) atBot :=
      tendsto_atBot_add_of_tendsto_atBot_of_tendsto h_neg_pole h_rem_tendsto

  exact (h_sum.congr' h_congr)

/-!
## 2. The Derivative Divergence (Stiffness)
We prove the "Stiffness" (second derivative) goes to -âˆ (without the minus sign).
This uses `stiffness_real_part_tendsto_atBot` from Residues.lean.
-/

/--
**Theorem: Infinite Stiffness at the Zero**
The derivative of the "Force" goes to -âˆ.
d/ds [ Î¶'/Î¶ ] â‰ˆ d/ds [ 1/(s-Ï) ] = -1/(s-Ï)Â².
On the real line, -1/(Ïƒ-Ï.re)Â² â†’ -âˆ.

Note: The derivative of -Î¶'/Î¶ goes to +âˆ.
-/
theorem log_deriv_derivative_divergence (Ï : â„‚)
    (h_strip : 0 < Ï.re âˆ§ Ï.re < 1)
    (h_zero : riemannZeta Ï = 0)
    (h_simple : deriv riemannZeta Ï â‰  0) :
    Filter.Tendsto (fun Ïƒ : â„ =>
      (deriv (fun z => -(deriv riemannZeta z / riemannZeta z)) (Ïƒ + Ï.im * I)).re)
    (ğ“[>] Ï.re) Filter.atTop := by

  -- Ï â‰  1 because it is inside the critical strip
  have h_not_one : Ï â‰  1 := by
    intro h_eq; rw [h_eq] at h_strip; simp only [one_re] at h_strip; linarith [h_strip.2]

  -- The derivative of -f is the negative of the derivative of f
  -- So if d/ds(Î¶'/Î¶) â†’ -âˆ, then d/ds(-Î¶'/Î¶) â†’ +âˆ
  have h_stiff := stiffness_real_part_tendsto_atBot Ï h_zero h_not_one h_simple

  -- Relate the two: deriv (-f) = -deriv f, so Re(deriv(-f)) = -Re(deriv f)
  -- If Re(deriv f) â†’ -âˆ, then -Re(deriv f) â†’ +âˆ
  have h_flip : Tendsto (fun Ïƒ : â„ =>
      -(deriv (fun z => deriv riemannZeta z / riemannZeta z) ((Ïƒ : â„‚) + Ï.im * I)).re)
      (ğ“[>] Ï.re) Filter.atTop :=
    tendsto_neg_atBot_atTop.comp h_stiff
  -- Show that deriv(-f) = -deriv(f), so Re(deriv(-f)) = -Re(deriv(f))
  -- This requires deriv_neg and real part linearity
  -- Reduce the goal to `h_flip` by rewriting `deriv (fun z => -(f z))`.
  have h_ident :
      (fun Ïƒ : â„ =>
          (deriv (fun z : â„‚ => -(deriv riemannZeta z / riemannZeta z))
                (Ïƒ + Ï.im * I)).re)
        =
      (fun Ïƒ : â„ =>
          -(deriv (fun z : â„‚ => deriv riemannZeta z / riemannZeta z)
                  ((Ïƒ : â„‚) + Ï.im * I)).re) := by
    funext Ïƒ
    -- `deriv_neg` gives `deriv (fun z => -(f z)) = fun z => -(deriv f z)`.
    -- Taking real parts commutes with negation.
    simp [deriv_neg]

  -- Finish by transporting the limit along the pointwise identity.
  simpa [h_ident] using h_flip

/-!
## 3. The Local Clustering Theorem
This replaces the "Global Axiom". We PROVE clustering *locally* near the zero
using the `AdmissibleStiffnessApproximation` hypothesis from Residues.lean.
-/

/--
**Lemma: weightedCosSum equals the NegativePhaseClustering sum**
The two formulations use syntactically different but mathematically equal expressions:
- `weightedCosSum`: uses `Real.log p * Real.log p`
- `NegativePhaseClustering`: uses `(Real.log p)^2`
These are definitionally equal via `sq`.
-/
lemma weightedCosSum_eq_clustering_sum (primes : List â„•) (Ïƒ t : â„) :
    weightedCosSum primes Ïƒ t =
      primes.foldl (fun (acc : â„) (p : â„•) =>
        acc + (Real.log p)^2 * (p : â„)^(-Ïƒ) * Real.cos (t * Real.log p)) 0 := by
  classical
  -- The proof is by induction on the prime list. After unfolding `weightedCosSum`,
  -- the only algebra is `log p * log p = (log p)^2` (i.e. `pow_two`).
  induction primes with
  | nil =>
      simp [weightedCosSum]
  | cons p ps ih =>
      -- `simp` rewrites the foldl step; `pow_two` resolves the square.
      simp [weightedCosSum, ih, pow_two, mul_assoc, mul_left_comm, mul_comm]

/--
**Theorem: Local Negative Phase Clustering**
Instead of assuming it globally, we PROVE it holds in a neighborhood of the zero
using the domination argument from Residues.lean.

The key hypothesis `AdmissibleStiffnessApproximation` encapsulates the Explicit Formula:
the finite prime sum approximates the stiffness (derivative of log derivative) with bounded error.
-/
theorem local_clustering_at_zero (Ï : â„‚) (h_zero : riemannZeta Ï = 0)
    (h_strip : 0 < Ï.re âˆ§ Ï.re < 1)
    (h_simple : deriv riemannZeta Ï â‰  0)
    (primes : List â„•) (h_primes : âˆ€ p âˆˆ primes, Nat.Prime p)
    (h_approx : AdmissibleStiffnessApproximation Ï primes) :
    âˆƒ Î´ : â„, 0 < Î´ âˆ§ âˆ€ Ïƒ âˆˆ Set.Ioo Ï.re (Ï.re + Î´),
      NegativePhaseClustering Ïƒ Ï.im primes := by

  -- 1. Apply the theorem from Residues.lean that proves the Finite Sum < 0
  have h_res := zeta_zero_gives_negative_clustering Ï h_zero h_strip h_simple primes h_primes h_approx

  -- 2. Re-pack as the `NegativePhaseClustering` definition
  obtain âŸ¨Î´, hÎ´_pos, h_negâŸ© := h_res
  use Î´, hÎ´_pos
  intro Ïƒ hÏƒ
  unfold NegativePhaseClustering
  -- Use the lemma to convert between the two sum formulations
  rw [â† weightedCosSum_eq_clustering_sum]
  exact h_neg Ïƒ hÏƒ

/-!
## 4. Eliminating the former global axiom

Earlier drafts carried a global axiom asserting `NegativePhaseClustering` for
all `Ïƒ âˆˆ (0,1)` whenever `Î¶(s)=0`.

That statement is *strictly stronger* than what is required downstream to
extract the critical-line conclusion.  What we actually need (and what the
residue/pole analysis delivers) is a **local forcing** statement near `Ïƒ = Re(s)`.

We therefore replace the former global lemma by two deterministic theorems:

1. `axiom_replacement`: local negativity on a right-neighborhood of `Re(s)`.
2. `exists_clustering_in_strip`: an existence form that produces at least one
   `Ïƒ âˆˆ (0,1)` with the required negativity.

Any subsequent strengthening from local to global can be pursued separately as
an analytic refinement, but it is not part of the core forcing mechanism.
-/

/--
**Axiom Replacement (Local Form).**

If `Î¶(Ï)=0` is a simple zero in the critical strip, and the prime sum
approximates the stiffness with bounded error (`AdmissibleStiffnessApproximation`),
then there is a right-neighborhood of `Re(Ï)` on which the weighted cosine sum is
strictly negative.

This is exactly the pole-domination statement proved in `Residues.lean`.
-/
theorem axiom_replacement (Ï : â„‚) (h_zero : riemannZeta Ï = 0)
    (h_strip : 0 < Ï.re âˆ§ Ï.re < 1)
    (h_simple : deriv riemannZeta Ï â‰  0)
    (primes : List â„•) (h_primes : âˆ€ p âˆˆ primes, Nat.Prime p)
    (h_approx : AdmissibleStiffnessApproximation Ï primes) :
    âˆƒ Î´ : â„, 0 < Î´ âˆ§ âˆ€ Ïƒ âˆˆ Set.Ioo Ï.re (Ï.re + Î´),
      NegativePhaseClustering Ïƒ Ï.im primes :=
  local_clustering_at_zero Ï h_zero h_strip h_simple primes h_primes h_approx

/--
**Existence Form (Strip Version).**

From the local neighborhood statement, we can always choose a point
`Ïƒ âˆˆ (0,1)` (indeed `Ïƒ > Re(Ï)`) on which `NegativePhaseClustering` holds.

This is the variant that is typically easiest to feed into later â€œmirror forcingâ€
arguments: it avoids any need for a global extension step.
-/
theorem exists_clustering_in_strip (Ï : â„‚) (h_zero : riemannZeta Ï = 0)
    (h_strip : 0 < Ï.re âˆ§ Ï.re < 1)
    (h_simple : deriv riemannZeta Ï â‰  0)
    (primes : List â„•) (h_primes : âˆ€ p âˆˆ primes, Nat.Prime p)
    (h_approx : AdmissibleStiffnessApproximation Ï primes) :
    âˆƒ Ïƒ : â„, Ïƒ âˆˆ Set.Ioo 0 1 âˆ§ NegativePhaseClustering Ïƒ Ï.im primes := by
  obtain âŸ¨Î´, hÎ´_pos, h_localâŸ© :=
    local_clustering_at_zero Ï h_zero h_strip h_simple primes h_primes h_approx

  -- Choose a point strictly between `Ï.re` and `Ï.re + Î´`, but also still < 1.
  let Î´' : â„ := min (Î´ / 2) ((1 - Ï.re) / 2)
  have hÎ´'_pos : 0 < Î´' := by
    have h1 : 0 < Î´ / 2 := by linarith
    have h2 : 0 < (1 - Ï.re) / 2 := by linarith [h_strip.2]
    exact lt_min h1 h2

  let Ïƒ0 : â„ := Ï.re + Î´'

  have hÏƒ0_in_strip : Ïƒ0 âˆˆ Set.Ioo 0 1 := by
    constructor
    Â· -- 0 < Ïƒ0
      have : 0 < Ï.re := h_strip.1
      linarith [hÎ´'_pos]
    Â· -- Ïƒ0 < 1
      have hÎ´'_le : Î´' â‰¤ (1 - Ï.re) / 2 := min_le_right _ _
      have hÏƒ0_le : Ïƒ0 â‰¤ Ï.re + (1 - Ï.re) / 2 := by linarith [hÎ´'_le]
      have h_mid_lt : Ï.re + (1 - Ï.re) / 2 < 1 := by linarith [h_strip.2]
      exact lt_of_le_of_lt hÏƒ0_le h_mid_lt

  have hÏƒ0_in_local : Ïƒ0 âˆˆ Set.Ioo Ï.re (Ï.re + Î´) := by
    constructor
    Â· -- Ï.re < Ïƒ0
      linarith [hÎ´'_pos]
    Â· -- Ïƒ0 < Ï.re + Î´
      have hÎ´'_le : Î´' â‰¤ Î´ / 2 := min_le_left _ _
      have hÏƒ0_le : Ïƒ0 â‰¤ Ï.re + Î´ / 2 := by linarith [hÎ´'_le]
      have h_half_lt : Ï.re + Î´ / 2 < Ï.re + Î´ := by linarith [hÎ´_pos]
      exact lt_of_le_of_lt hÏƒ0_le h_half_lt

  refine âŸ¨Ïƒ0, hÏƒ0_in_strip, ?_âŸ©
  exact h_local Ïƒ0 hÏƒ0_in_local

end ProofEngine.PhaseClustering
