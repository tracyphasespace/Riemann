/-
# Compression: Generic Finite-Dimensional Framework

**Purpose**: Provide a model-agnostic framework for compressing the infinite-dimensional
operator to a finite-dimensional subspace, yielding a concrete determinant.

## Strategy

Given any `CompletedModel M`, we:
1. Choose a finite-dimensional subspace W ⊆ M.H
2. Define orthogonal projection P_W onto W
3. Define compressed operator OpW = P ∘ Op ∘ P
4. Compute matrix representation in orthonormal basis
5. Define detLike = det(I - A) as actual matrix determinant

This makes `detLike` non-axiomatic and fully computable.

## Design Choice

The compression subspace W is generated by whatever "atoms" you want (wavelets,
Fourier modes, etc.), but the orthonormal basis for the matrix is chosen abstractly
via Gram-Schmidt. This avoids requiring explicit orthogonality between atoms.

## References

- CompletionCore.lean (CompletedModel interface)
- Mathlib orthogonal projection and matrix determinant
-/

import Mathlib.Analysis.InnerProductSpace.Projection.Basic
import Mathlib.Analysis.InnerProductSpace.Adjoint
import Mathlib.LinearAlgebra.Matrix.Determinant.Basic
import Mathlib.Data.Finset.Basic
import Mathlib.LinearAlgebra.Dimension.Finrank

import Riemann.ZetaSurface.CompletionCore

noncomputable section
open scoped Real ComplexConjugate
open Complex

namespace Riemann.ZetaSurface

/-!
## Notation: `.im` = B-coefficient in Cl(N,N)

In the Cl(N,N) geometric framework, the "imaginary part" accessed via `.im` is
actually the **B-coefficient** under the isomorphism Span{1,B} ≅ ℂ where B² = -1.
Everything in Cl(N,N) is real - see `RayleighBridge.lean` for details.
-/

/-! ## 1. CompressionData Structure -/

/--
Generic finite-dimensional compression datum.

We avoid requiring an explicit orthonormal family in the ambient space.
Instead, we:
- Choose a subspace W ⊆ H generated by whatever "atoms" you want
- Assume W is finite-dimensional (then W is complete)
- Choose an orthonormal basis of W (abstractly via existence)

This keeps Compression.lean purely structural.
-/
structure CompressionData (M : CompletedModel) where
  /-- The finite-dimensional subspace to compress onto. -/
  W : Submodule ℂ M.H

  /-- Proof that W is finite-dimensional. -/
  finiteDim : FiniteDimensional ℂ W

  /-- Index type for the basis. -/
  ι : Type

  /-- ι is a finite type. -/
  instFintype : Fintype ι

  /-- ι has decidable equality. -/
  instDecEq : DecidableEq ι

  /-- Orthonormal basis of W indexed by ι. -/
  e : OrthonormalBasis ι ℂ W

attribute [instance] CompressionData.instFintype
attribute [instance] CompressionData.instDecEq
attribute [instance] CompressionData.finiteDim

/-! ## 2. Compression Operations -/

namespace CompressionData

variable {M : CompletedModel} (C : CompressionData M)

/-- Finite-dimensional inner product spaces are complete. -/
instance instCompleteSpace : CompleteSpace C.W := FiniteDimensional.complete ℂ C.W

/--
Orthogonal projection H → W.

This exists because W is a complete submodule of the inner product space H.
-/
def projToW : M.H →L[ℂ] C.W :=
  C.W.orthogonalProjection

/--
Inclusion W → H (the submodule inclusion as a continuous linear map).
-/
def incl : C.W →L[ℂ] M.H :=
  C.W.subtypeL

/--
Orthogonal projection H → H onto W.

P = incl ∘ proj : H → W → H
-/
def projOnH : M.H →L[ℂ] M.H :=
  (incl C).comp (projToW C)

/--
Compressed operator on H:

  OpW(s,B) = P ∘ Op(s,B) ∘ P

where P is orthogonal projection onto W (as an operator on H).
-/
def OpW (s : ℂ) (B : ℕ) : M.H →L[ℂ] M.H :=
  (projOnH C).comp ((M.Op s B).comp (projOnH C))

/-! ## 3. Matrix Representation -/

/--
Ambient basis vector φ_i ∈ H, obtained from orthonormal basis e_i ∈ W.
-/
def phi (i : C.ι) : M.H :=
  (incl C) (C.e i)

/--
The φ_i are orthonormal in H.
-/
theorem phi_orthonormal : Orthonormal ℂ (phi C) := by
  -- The inclusion preserves inner products, and e is orthonormal in W.
  -- Orthonormal = (∀ i, ‖v i‖ = 1) ∧ Pairwise (⟪v i, v j⟫ = 0)
  constructor
  · -- ∀ i, ‖φ_i‖ = 1
    intro i
    unfold phi incl
    -- ‖(e i : M.H)‖ = ‖e i‖ in W = 1
    have h := C.e.orthonormal.1 i
    rw [← h]
    rfl
  · -- Pairwise: ⟨φ_i, φ_j⟩ = 0 for i ≠ j
    intro i j hij
    unfold phi incl
    -- ⟨(e i : M.H), (e j : M.H)⟩ = ⟨e i, e j⟩ in W = 0
    have h := C.e.orthonormal.2 hij
    rw [← h]
    rfl

/--
Matrix of the compressed operator in the basis {φ_i}.

  A_{ij} = ⟨φ_i, OpW(s,B)(φ_j)⟩
-/
def mat (s : ℂ) (B : ℕ) : Matrix C.ι C.ι ℂ :=
  fun i j => @inner ℂ _ _ (phi C i) ((OpW C s B) (phi C j))

/--
The characteristic matrix: I - A.
-/
def charMat (s : ℂ) (B : ℕ) : Matrix C.ι C.ι ℂ :=
  (1 : Matrix C.ι C.ι ℂ) - mat C s B

/-! ## 4. The Determinant -/

/--
**The concrete determinant-like invariant.**

detLike(s, B) := det(I - A)

This is a genuine matrix determinant, fully computable.
-/
def detLike (s : ℂ) (B : ℕ) : ℂ :=
  Matrix.det (charMat C s B)

/--
Equivalently: det(I - mat).
-/
theorem detLike_eq (s : ℂ) (B : ℕ) :
    detLike C s B = Matrix.det ((1 : Matrix C.ι C.ι ℂ) - mat C s B) := rfl

/-! ## 5. Properties of Compressed Operator -/

/--
The compressed operator preserves W: OpW maps into the range of P.
-/
theorem OpW_range (s : ℂ) (B : ℕ) :
    ∀ v : M.H, OpW C s B v ∈ (LinearMap.range (incl C).toLinearMap) := by
  intro v
  -- OpW = incl ∘ proj ∘ Op ∘ incl ∘ proj, so result is in range(incl)
  unfold OpW projOnH
  simp only [ContinuousLinearMap.comp_apply]
  exact LinearMap.mem_range.mpr ⟨_, rfl⟩

/--
The projection onto H (incl ∘ proj) is self-adjoint.
-/
theorem projOnH_selfadjoint : (projOnH C).adjoint = projOnH C := by
  unfold projOnH projToW incl
  -- (incl ∘ proj)† = proj† ∘ incl†
  rw [ContinuousLinearMap.adjoint_comp]
  -- proj† = incl and incl† = proj by Mathlib lemmas
  rw [Submodule.adjoint_orthogonalProjection]
  rw [Submodule.adjoint_subtypeL]

/--
If the original operator is self-adjoint on the critical line,
then so is the compressed operator (on W).
-/
theorem OpW_selfadjoint_critical (t : ℝ) (B : ℕ) :
    let s : ℂ := (1/2 : ℂ) + (t : ℂ) * I
    (OpW C s B).adjoint = OpW C s B := by
  intro s
  have hA : (M.Op s B).adjoint = M.Op s B := M.selfadjoint_critical t B
  unfold OpW
  -- (P ∘ (Op ∘ P))† = (Op ∘ P)† ∘ P† = (P† ∘ Op†) ∘ P†
  rw [ContinuousLinearMap.adjoint_comp, ContinuousLinearMap.adjoint_comp]
  -- Now substitute P† = P and Op† = Op
  rw [projOnH_selfadjoint C, hA]
  -- Goal: (P ∘ Op) ∘ P = P ∘ (Op ∘ P), which is associativity
  exact ContinuousLinearMap.comp_assoc _ _ _

/--
Self-adjointness implies the matrix is Hermitian.
-/
theorem mat_hermitian_critical (t : ℝ) (B : ℕ) :
    let s : ℂ := (1/2 : ℂ) + (t : ℂ) * I
    Matrix.conjTranspose (mat C s B) = mat C s B := by
  -- A_{ji}* = ⟨φ_j, OpW(φ_i)⟩* = ⟨OpW(φ_i), φ_j⟩ = ⟨φ_i, OpW†(φ_j)⟩
  -- If OpW = OpW†, then = ⟨φ_i, OpW(φ_j)⟩ = A_{ij}
  intro s
  have hOpW : (OpW C s B).adjoint = OpW C s B := OpW_selfadjoint_critical C t B
  ext i j
  simp only [Matrix.conjTranspose_apply]
  unfold mat
  -- Goal: star (inner (phi j) (OpW (phi i))) = inner (phi i) (OpW (phi j))
  -- Convert star to starRingEnd (they are definitionally equal on ℂ)
  show (starRingEnd ℂ) (@inner ℂ _ _ (phi C j) (OpW C s B (phi C i))) =
       @inner ℂ _ _ (phi C i) (OpW C s B (phi C j))
  -- star (inner y x) = inner x y by inner_conj_symm
  rw [inner_conj_symm (OpW C s B (phi C i)) (phi C j)]
  -- Goal: inner (OpW (phi i)) (phi j) = inner (phi i) (OpW (phi j))
  -- Use adjoint: inner (A x) y = inner x (A† y) (via ← adjoint_inner_right)
  rw [← ContinuousLinearMap.adjoint_inner_right (OpW C s B)]
  -- Goal: inner (phi i) (OpW† (phi j)) = inner (phi i) (OpW (phi j))
  rw [hOpW]

/--
I - A is Hermitian when A is Hermitian.
-/
theorem charMat_hermitian_critical (t : ℝ) (B : ℕ) :
    let s : ℂ := (1/2 : ℂ) + (t : ℂ) * I
    Matrix.conjTranspose (charMat C s B) = charMat C s B := by
  intro s
  unfold charMat
  -- (I - A)ᴴ = Iᴴ - Aᴴ = I - A (since I and A are Hermitian)
  rw [Matrix.conjTranspose_sub, Matrix.conjTranspose_one]
  rw [mat_hermitian_critical C t B]

/--
For Hermitian matrices, det is real: if Aᴴ = A then det(A) = star(det(A)).
-/
theorem det_real_of_hermitian {n : Type*} [Fintype n] [DecidableEq n]
    (A : Matrix n n ℂ) (hA : Matrix.conjTranspose A = A) :
    (Matrix.det A).im = 0 := by
  -- det(Aᴴ) = star(det(A)) by det_conjTranspose
  -- If Aᴴ = A, then det(A) = star(det(A)), so det(A) is real
  have h : Matrix.det A = star (Matrix.det A) := by
    rw [← Matrix.det_conjTranspose A, hA]
  -- star z = z means z.im = 0
  have h_im : (Matrix.det A).im = -(Matrix.det A).im := by
    have := congrArg Complex.im h
    simp only [Complex.star_def, Complex.conj_im] at this
    exact this
  linarith

/--
For Hermitian matrices, det(I - A) is real when eigenvalues are real.
-/
theorem detLike_real_critical (t : ℝ) (B : ℕ) :
    let s : ℂ := (1/2 : ℂ) + (t : ℂ) * I
    (detLike C s B).im = 0 := by
  intro s
  unfold detLike
  -- charMat is Hermitian on critical line
  exact det_real_of_hermitian (charMat C s B) (charMat_hermitian_critical C t B)

end CompressionData

/-! ## 6. Integration Notes -/

/-
To use this framework:

1. Choose a `CompletedModel M` (e.g., `KernelModel` or `MeasureModel w`)
2. Construct a `CompressionData M` by:
   - Defining a subspace W (e.g., span of wavelet atoms)
   - Proving W is finite-dimensional
   - Choosing index type ι = Fin (finrank W)
   - Obtaining orthonormal basis via existence theorem
3. Compute `CompressionData.detLike C s B` for your compression C

This gives a concrete, non-axiomatic determinant that can be:
- Numerically evaluated
- Compared to finite Euler products
- Used to study zeros of ζ
-/

end Riemann.ZetaSurface

end
